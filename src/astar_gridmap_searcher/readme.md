
## 项目介绍
基于ROS，采用c++编码，实现了Astar路径搜索算法，并进行了可视化显示。
## 具体细节
1、将几种主流的启发式函数均加入其中，可以适用于不同的地图环境
2、参考融合了一些fastplanner中Astar算法中的一些工程上的优秀代码实现，比如优先级队列、哈希表等
3、g和h均加入了权值，可以实现多种算法，即f = a\*g + b\*h。a b区别不同，算法也就不同。比如0 1，这时变成了most greedy；1 kesei(>1) 变成了tunable greediness等

## 算法笔记

### Heuristic design
欧几里得距离也就是二范数  总是满足最优性 admissible
曼哈顿距离也就是一范数 看情况 若机器人可以对角线移动，则不是admissible；若只能前后左右移动，是admissible

## 工程优化 trick
tie breaker

## Dijkstra VS A*
dijkstra的优点是完备性、最优性，缺点是没有目标和方向，搜索速度很慢。
A*相当于是在前者的基础上加了启发式函数，有了一定的目标和方向。并且若h（n）<=h（n）\*，则最优性是满足的。

1. 若h=0，A*则退化为dijkstra
2. 如果h（n）<< << h(n)\*，A\*算法可以找到最短路径（也就是满足了最优性）,但是搜索效率很低，也就是目标导向性不是很强，这样的话会导致搜索的节点变多，也就导致了搜索时间变长。
3. 当h（n）== h（n）\*时，A\*到达了最优状态，最优性和快速性同时满足！
4. 若h（n）>> >> g（n），那么这时候f主要取决于h（n），A*算法退化为贪婪最佳优先搜索算法 greedy best first search。h权值越大，搜索目的性越强，效率更高，但是很容易陷入局部最优中。


## 算法测试
使用对角距离作为启发函数，在有障碍物的情况下，效果并不是很好，